/**
 * File: bootAnim.cpp
 *
 * Author: Al Chaussee
 * Created: 07/27/2018
 *
 * Description: Draws the boot animation to the screen forever until stopped
 *              Leaves the screen on when stopped under the assumption whatever is stopping
 *              it will continue to use the screen
 *
 * Copyright: Anki, Inc. 2018
 *
 **/

#include "core/lcd.h"

#include <stdio.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <chrono>
#include <algorithm>
#include <signal.h>


#define FRAME_WIDTH_SANTEK  184
#define FRAME_HEIGHT_SANTEK 96
#define FRAME_WIDTH_MIDAS 160
#define FRAME_HEIGHT_MIDAS 80
#define NUM_BYTES_PER_FRAME_SANTEK (FRAME_WIDTH_SANTEK * FRAME_HEIGHT_SANTEK * sizeof(uint16_t))
#define NUM_BYTES_PER_FRAME_MIDAS (FRAME_WIDTH_MIDAS * FRAME_HEIGHT_MIDAS * sizeof(uint16_t))

namespace {
  // Path to the boot animation file generated by `python3 /robot/test/gif_to_raw.py <gif of boot animation>`
  // It is a binary file containing all the frames in the animation in rgb565 format
  static const char* _animPathSantek = "/anki/data/assets/cozmo_resources/config/engine/animations/boot_anim.raw";
  static const char* _animPathMidas = "/anki/data/assets/cozmo_resources/config/engine/animations/boot_anim_20.raw";
  bool gShutdown = false;
}

extern "C" void core_common_on_exit(void)
{
  lcd_shutdown();
}

bool use_santek_sizes() {
  return lcd_display_version() == SANTEK;
}

static void animate(void* frame)
{
  if (use_santek_sizes()) {
    lcd_draw_frame2((uint16_t*)frame, FRAME_WIDTH_SANTEK * FRAME_HEIGHT_SANTEK * sizeof(uint16_t));
  } else {
    lcd_draw_frame2((uint16_t*)frame, FRAME_WIDTH_MIDAS * FRAME_HEIGHT_MIDAS * sizeof(uint16_t));
  };
}

static void handler(int signum)
{
  gShutdown = true;
}

static void interpolate_frames(void* frame1, void* frame2, void* output, float blend)
{
  const size_t num_pixels = use_santek_sizes() ?
    (FRAME_WIDTH_SANTEK * FRAME_HEIGHT_SANTEK) :
    (FRAME_WIDTH_MIDAS * FRAME_HEIGHT_MIDAS);

  uint16_t* src1 = (uint16_t*)frame1;
  uint16_t* src2 = (uint16_t*)frame2;
  uint16_t* dst = (uint16_t*)output;

  for (size_t i = 0; i < num_pixels; i++)
  {
    uint16_t r1 = (src1[i] >> 11) & 0x1F;
    uint16_t g1 = (src1[i] >> 5) & 0x3F;
    uint16_t b1 = src1[i] & 0x1F;

    uint16_t r2 = (src2[i] >> 11) & 0x1F;
    uint16_t g2 = (src2[i] >> 5) & 0x3F;
    uint16_t b2 = src2[i] & 0x1F;

    uint16_t r = r1 + (uint16_t)((r2 - r1) * blend);
    uint16_t g = g1 + (uint16_t)((g2 - g1) * blend);
    uint16_t b = b1 + (uint16_t)((b2 - b1) * blend);

    dst[i] = (r << 11) | (g << 5) | b;
  }
}

int main(int argc, char** argv)
{
  // Setup signal handlers so we can cleanly exit
  signal(SIGTERM, handler);
  signal(SIGINT,  handler);

  // lcd_init();
  // lcd_clear_screen();
  // lcd_shutdown();

  // Init lcd
  int rc = lcd_init();
  if (rc != 0)
  {
    printf("Failed to init lcd\n");
    return rc;
  }

  // Open animation file for reading
  const char *anim_path = use_santek_sizes() ? _animPathSantek : _animPathMidas;

  int fd = open(anim_path, O_RDONLY, 644);
  if(fd < 0)
  {
    printf("Failed to open %s\n", anim_path);
    return -1;
  }

  // Get the length of the file to determine how long the animation is
  off_t len = lseek(fd, 0, SEEK_END);
  if(len == -1)
  {
    printf("lseek failed\n");
    return -1;
  }
  static const uint32_t kTotalNumFrames = len / ( use_santek_sizes() ? NUM_BYTES_PER_FRAME_SANTEK : NUM_BYTES_PER_FRAME_MIDAS);

  // Memory map the anim file
  void* anim = mmap(nullptr, len, PROT_READ, MAP_PRIVATE, fd, 0);
  if(anim == nullptr)
  {
    printf("mmap failed\n");
    return -1;
  }

  // Close the fd after memory mapping
  rc = close(fd);
  if(rc != 0)
  {
    printf("close failed\n");
  }  

  const size_t frame_size = use_santek_sizes() ?
    NUM_BYTES_PER_FRAME_SANTEK : NUM_BYTES_PER_FRAME_MIDAS;
  void* interpBuffer = malloc(frame_size);
  if (interpBuffer == nullptr)
  {
    printf("Failed to allocate interpolation buffer\n");
    munmap(anim, len);
    lcd_shutdown();
    return -1;
  }

  // Start drawing the boot animation to the screen

  // Keep track of how far in time we are in this loop of the animation
  // since drawing the frame takes longer than the frame should actually
  // be displayed (~50ms to draw vs a desired frame rate of 30fps)
  // we need to skip frames
  uint32_t timeCount = 0;
  
  while (!gShutdown)
  {
    // Figure out which frame we should play in order to adhere to
    // a frame rate of kFrameDuration_ms
    bool use60 = true; // 60fps mode
    static const uint32_t kSourceFrameDuration_ms = 33; // 30fps
    static const uint32_t kTargetFrameDuration_ms = use60 ? 16 : 33; // 60fps or 30fps

    // Time how long it takes to animate/draw this frame
    const auto startTime = std::chrono::steady_clock::now();
    const uint32_t frame_offset = use_santek_sizes() ? NUM_BYTES_PER_FRAME_SANTEK : NUM_BYTES_PER_FRAME_MIDAS;

    if (use60)
    {
      const float animPosition = (timeCount % (kTotalNumFrames * kSourceFrameDuration_ms));

      const uint32_t sourceFrame = (uint32_t)(animPosition / kSourceFrameDuration_ms);
      const uint32_t nextSourceFrame = (sourceFrame + 1) % kTotalNumFrames;

      const float timeInFrame = fmod(animPosition, kSourceFrameDuration_ms);
      const float blend = timeInFrame / kSourceFrameDuration_ms;

      void* frame1 = ((uint8_t*)anim) + (sourceFrame * frame_offset);
      void* frame2 = ((uint8_t*)anim) + (nextSourceFrame * frame_offset);

      interpolate_frames(frame1, frame2, interpBuffer, blend);
      animate(interpBuffer);
    }
    else
    {
      const uint32_t nextFrameToDraw = timeCount / kSourceFrameDuration_ms;
      animate(((uint8_t*)anim) + (nextFrameToDraw * frame_offset));
    }

    const auto endTime = std::chrono::steady_clock::now();

    const auto dif = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);

    if (dif.count() < kTargetFrameDuration_ms)
    {
      const useconds_t sleep_us = (useconds_t)((kTargetFrameDuration_ms - dif.count()) * 1000);
      usleep(sleep_us);
    }

    timeCount += kTargetFrameDuration_ms;

    if(timeCount >= (kTotalNumFrames * kSourceFrameDuration_ms))
    {
      timeCount = 0;
    }
  }
  free(interpBuffer);

  // Unmap the anim
  rc = munmap(anim, len);
  if(rc != 0)
  {
    printf("munmap failed\n");
  }

  lcd_shutdown();
  return 0;
}

